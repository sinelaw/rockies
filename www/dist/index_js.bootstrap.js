"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["index_js"],{

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rockies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rockies */ \"./node_modules/rockies/index.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'rockies/rockies_bg.wasm'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([rockies__WEBPACK_IMPORTED_MODULE_0__]);\nrockies__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst canvas = document.getElementById(\"the-canvas\");\n\nconst SIZE = 64;\nconst CELL_SIZE = Math.min(canvas.clientWidth / SIZE, canvas.clientHeight / SIZE) | 0; // px\n\n\nconst game = rockies__WEBPACK_IMPORTED_MODULE_0__.Game.new(SIZE, SIZE);\nconst width = game.width();\nconst height = game.height();\n\nconst ticks = document.getElementById(\"ticks\");\nconst version = document.getElementById(\"version\");\nconst cells_count = document.getElementById(\"cells-count\");\nconst collisions_count = document.getElementById(\"collisions-count\");\nconst collision_pairs_tested = document.getElementById(\"collision-pairs-tested\");\nconst touches = document.getElementById(\"touches\");\nconst dig_checkbox = document.getElementById(\"dig-checkbox\");\n\ncanvas.height = (CELL_SIZE) * height + 1;\ncanvas.width = (CELL_SIZE) * width + 1;\n\nversion.textContent = game.version();\n\nconst ctx = canvas.getContext('2d');\n\nfunction loadAndSave() {\n\n    let grids_to_save = game.get_grids_to_save();\n    for (const grid_index of grids_to_save) {\n        const grid = game.save_grid(grid_index);\n        // save to LocalStorage\n        localStorage.setItem(`grid_${grid_index}`, grid);\n    }\n\n    // Load grids from LocalStorage \n    let grids_to_load = game.get_grids_to_load();\n    for (const grid_index of grids_to_load) {\n        const grid = localStorage.getItem(`grid_${grid_index}`);\n        if (grid) {\n            game.load_grid(grid_index, grid);\n        }\n    }\n}\n\nconst renderLoop = () => {\n\n    game.tick();\n\n    loadAndSave();\n\n    drawPixels();\n\n    let stats = game.stats();\n\n    ticks.textContent = stats.ticks();\n    cells_count.textContent = stats.cells_count();\n    collisions_count.textContent = (stats.collisions_count() / stats.ticks()) | 0;\n    collision_pairs_tested.textContent = (stats.collision_pairs_tested() / stats.ticks()) | 0;\n\n\n\n    requestAnimationFrame(renderLoop);\n};\n\nconst getIndex = (row, column) => {\n    return row * width + column;\n};\n\nconst drawPixels = () => {\n    const pixelsPtr = game.pixels();\n    const pixels = new Uint32Array(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'rockies/rockies_bg.wasm'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).buffer, pixelsPtr, width * height);\n\n    for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n            const idx = getIndex(row, col);\n            ctx.beginPath();\n\n            let val = pixels[idx];\n            ctx.fillStyle = \"#\" + val.toString(16).padStart(6, \"0\");\n            //console.log(\"[%d,%d] = %s = %s\", row, col, pixels[idx].toString(16), ctx.fillStyle);\n\n            ctx.fillRect(\n                col * CELL_SIZE + 1,\n                row * CELL_SIZE + 1,\n                CELL_SIZE,\n                CELL_SIZE\n            );\n\n            ctx.stroke();\n        }\n    }\n\n};\n\ndrawPixels();\nrequestAnimationFrame(renderLoop);\n\ncanvas.onmousemove = (e) => {\n    if (e.buttons > 0) {\n        game.click(e.offsetX / (CELL_SIZE + 1), e.offsetY / (CELL_SIZE + 1));\n    }\n};\n\ncanvas.onclick = (e) => {\n    game.click(e.offsetX / (CELL_SIZE + 1), e.offsetY / (CELL_SIZE + 1));\n};\n\ncanvas.addEventListener('blur', function (event) {\n    game.unfocus();\n});\n\nwindow.addEventListener('blur', function (event) {\n    game.unfocus();\n});\n\nlet is_shift_down = () => {\n    return dig_checkbox.checked;\n\n};\n\n// Helper function to find buttons by key\nconst findButtonsByKey = (key) => {\n    return Array.from(document.querySelectorAll('.move-button, .move-button-checkbox')).filter(el => {\n        const keys = (el.dataset.keys || '').split(',');\n        return keys.includes(key.toLowerCase());\n    });\n};\n\n// Helper functions to activate/deactivate buttons\nconst activateButton = (button) => {\n    if (button.classList.contains('move-button-checkbox')) {\n        if (!button.dataset.keys) return; // Skip buttons without key mappings\n        const keys = button.dataset.keys.split(',');\n        keys.forEach(key => {\n            if (pressedKeys.has(key)) {\n                button.checked = true;\n            }\n        });\n        // Trigger the change event so handlers are notified\n        button.dispatchEvent(new Event('change'));\n    } else {\n        button.classList.add('active');\n    }\n};\n\nconst deactivateButton = (button) => {\n    if (button.classList.contains('move-button-checkbox')) {\n        if (!button.dataset.keys) return; // Skip buttons without key mappings\n        const keys = button.dataset.keys.split(',');\n        keys.forEach(key => {\n            if (!pressedKeys.has(key)) {\n                button.checked = false;\n            }\n        });\n        // Trigger the change event so handlers are notified\n        button.dispatchEvent(new Event('change'));\n    } else {\n        button.classList.remove('active');\n    }\n};\n\n// Track currently pressed keys\nconst pressedKeys = new Set();\nlet shiftToggled = false;\n\n// Helper function to normalize key names\nconst normalizeKey = (key) => {\n    key = key.toLowerCase();\n    switch (key) {\n        case 'arrowup': return 'w';\n        case 'arrowdown': return 's';\n        case 'arrowleft': return 'a';\n        case 'arrowright': return 'd';\n        case ' ': return ' ';\n    }\n    return key;\n};\n\nconst findButtonElements = () => {\n    return Array.from(document.querySelectorAll('.move-button, .move-button-checkbox'));\n};\n\n// Update all button states based on currently pressed keys\nconst updateAllButtonStates = () => {\n    const elems = findButtonElements();\n\n    elems.filter(el => {\n        const buttonKeys = (el.dataset.keys || '').split(',').map(k => normalizeKey(k));\n        // For combination buttons (e.g. w+a)\n        if (buttonKeys.every(key => pressedKeys.has(key))) {\n            activateButton(el);\n        } else {\n            deactivateButton(el);\n        }\n    });\n};\n\n// Handle keyboard events\ndocument.onkeydown = (e) => {\n    const key = normalizeKey(e.key);\n    pressedKeys.add(key);\n    touches.textContent = key;\n    game.key_down(key);\n    updateAllButtonStates();\n};\n\ndocument.onkeyup = (e) => {\n    const key = normalizeKey(e.key);\n    pressedKeys.delete(key);\n    touches.textContent = key;\n    game.key_up(key);\n    updateAllButtonStates();\n};\n\n// Clear pressed keys when window loses focus\nwindow.onblur = () => {\n    pressedKeys.clear();\n    updateAllButtonStates();\n};\n\n// Setup control buttons\nconst setupControlButtons = () => {\n    // Special handling for shift checkbox\n    const toggleButtons = document.querySelectorAll('.move-button-checkbox');\n    toggleButtons.forEach(checkbox => {\n        if (!checkbox.dataset.keys) return; // Skip buttons without key mappings\n        const keys = checkbox.dataset.keys.split(',');\n        if (keys.includes('shift')) {\n            const handleChange = () => {\n                if (checkbox.checked) {\n                    pressedKeys.add('shift');\n                    game.key_down('shift');\n                } else {\n                    pressedKeys.delete('shift');\n                    game.key_up('shift');\n                }\n            };\n\n            checkbox.addEventListener('change', handleChange);\n            return; // Skip regular event binding for shift button\n        }\n    });\n\n    const buttons = document.querySelectorAll('.move-button');\n\n    buttons.forEach(button => {\n        if (!button.dataset.keys) return; // Skip buttons without key mappings\n        const keys = button.dataset.keys.split(',');\n\n        console.log(\"Button: \", button, \"Keys: \", keys);\n        const pressKeys = () => keys.forEach(key => game.key_down(key));\n        const releaseKeys = () => keys.forEach(key => game.key_up(key));\n\n        // Mouse events\n        button.addEventListener('mousedown', pressKeys);\n        button.addEventListener('mouseup', releaseKeys);\n        button.addEventListener('mouseleave', releaseKeys);\n\n        // Touch events\n        button.addEventListener('touchstart', (e) => {\n            e.preventDefault(); // Prevent double-firing on mobile\n            pressKeys();\n        });\n        button.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            releaseKeys();\n        });\n        button.addEventListener('touchcancel', (e) => {\n            e.preventDefault();\n            releaseKeys();\n        });\n\n        // Blur event (when button loses focus)\n        button.addEventListener('blur', releaseKeys);\n    });\n\n\n};\n\n// Initialize controls\nsetupControlButtons();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vaW5kZXguanM/NDFmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW1lLCBDZWxsIH0gZnJvbSBcInJvY2tpZXNcIjtcbmltcG9ydCB7IG1lbW9yeSB9IGZyb20gXCJyb2NraWVzL3JvY2tpZXNfYmcud2FzbVwiO1xuXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRoZS1jYW52YXNcIik7XG5cbmNvbnN0IFNJWkUgPSA2NDtcbmNvbnN0IENFTExfU0laRSA9IE1hdGgubWluKGNhbnZhcy5jbGllbnRXaWR0aCAvIFNJWkUsIGNhbnZhcy5jbGllbnRIZWlnaHQgLyBTSVpFKSB8IDA7IC8vIHB4XG5cblxuY29uc3QgZ2FtZSA9IEdhbWUubmV3KFNJWkUsIFNJWkUpO1xuY29uc3Qgd2lkdGggPSBnYW1lLndpZHRoKCk7XG5jb25zdCBoZWlnaHQgPSBnYW1lLmhlaWdodCgpO1xuXG5jb25zdCB0aWNrcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGlja3NcIik7XG5jb25zdCB2ZXJzaW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2ZXJzaW9uXCIpO1xuY29uc3QgY2VsbHNfY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNlbGxzLWNvdW50XCIpO1xuY29uc3QgY29sbGlzaW9uc19jb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGlzaW9ucy1jb3VudFwiKTtcbmNvbnN0IGNvbGxpc2lvbl9wYWlyc190ZXN0ZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbGxpc2lvbi1wYWlycy10ZXN0ZWRcIik7XG5jb25zdCB0b3VjaGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0b3VjaGVzXCIpO1xuY29uc3QgZGlnX2NoZWNrYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaWctY2hlY2tib3hcIik7XG5cbmNhbnZhcy5oZWlnaHQgPSAoQ0VMTF9TSVpFKSAqIGhlaWdodCArIDE7XG5jYW52YXMud2lkdGggPSAoQ0VMTF9TSVpFKSAqIHdpZHRoICsgMTtcblxudmVyc2lvbi50ZXh0Q29udGVudCA9IGdhbWUudmVyc2lvbigpO1xuXG5jb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuZnVuY3Rpb24gbG9hZEFuZFNhdmUoKSB7XG5cbiAgICBsZXQgZ3JpZHNfdG9fc2F2ZSA9IGdhbWUuZ2V0X2dyaWRzX3RvX3NhdmUoKTtcbiAgICBmb3IgKGNvbnN0IGdyaWRfaW5kZXggb2YgZ3JpZHNfdG9fc2F2ZSkge1xuICAgICAgICBjb25zdCBncmlkID0gZ2FtZS5zYXZlX2dyaWQoZ3JpZF9pbmRleCk7XG4gICAgICAgIC8vIHNhdmUgdG8gTG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBncmlkXyR7Z3JpZF9pbmRleH1gLCBncmlkKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGdyaWRzIGZyb20gTG9jYWxTdG9yYWdlIFxuICAgIGxldCBncmlkc190b19sb2FkID0gZ2FtZS5nZXRfZ3JpZHNfdG9fbG9hZCgpO1xuICAgIGZvciAoY29uc3QgZ3JpZF9pbmRleCBvZiBncmlkc190b19sb2FkKSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShgZ3JpZF8ke2dyaWRfaW5kZXh9YCk7XG4gICAgICAgIGlmIChncmlkKSB7XG4gICAgICAgICAgICBnYW1lLmxvYWRfZ3JpZChncmlkX2luZGV4LCBncmlkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgcmVuZGVyTG9vcCA9ICgpID0+IHtcblxuICAgIGdhbWUudGljaygpO1xuXG4gICAgbG9hZEFuZFNhdmUoKTtcblxuICAgIGRyYXdQaXhlbHMoKTtcblxuICAgIGxldCBzdGF0cyA9IGdhbWUuc3RhdHMoKTtcblxuICAgIHRpY2tzLnRleHRDb250ZW50ID0gc3RhdHMudGlja3MoKTtcbiAgICBjZWxsc19jb3VudC50ZXh0Q29udGVudCA9IHN0YXRzLmNlbGxzX2NvdW50KCk7XG4gICAgY29sbGlzaW9uc19jb3VudC50ZXh0Q29udGVudCA9IChzdGF0cy5jb2xsaXNpb25zX2NvdW50KCkgLyBzdGF0cy50aWNrcygpKSB8IDA7XG4gICAgY29sbGlzaW9uX3BhaXJzX3Rlc3RlZC50ZXh0Q29udGVudCA9IChzdGF0cy5jb2xsaXNpb25fcGFpcnNfdGVzdGVkKCkgLyBzdGF0cy50aWNrcygpKSB8IDA7XG5cblxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckxvb3ApO1xufTtcblxuY29uc3QgZ2V0SW5kZXggPSAocm93LCBjb2x1bW4pID0+IHtcbiAgICByZXR1cm4gcm93ICogd2lkdGggKyBjb2x1bW47XG59O1xuXG5jb25zdCBkcmF3UGl4ZWxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHBpeGVsc1B0ciA9IGdhbWUucGl4ZWxzKCk7XG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIHBpeGVsc1B0ciwgd2lkdGggKiBoZWlnaHQpO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3crKykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB3aWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGdldEluZGV4KHJvdywgY29sKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgbGV0IHZhbCA9IHBpeGVsc1tpZHhdO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI1wiICsgdmFsLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LCBcIjBcIik7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiWyVkLCVkXSA9ICVzID0gJXNcIiwgcm93LCBjb2wsIHBpeGVsc1tpZHhdLnRvU3RyaW5nKDE2KSwgY3R4LmZpbGxTdHlsZSk7XG5cbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICBjb2wgKiBDRUxMX1NJWkUgKyAxLFxuICAgICAgICAgICAgICAgIHJvdyAqIENFTExfU0laRSArIDEsXG4gICAgICAgICAgICAgICAgQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgIENFTExfU0laRVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5kcmF3UGl4ZWxzKCk7XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyTG9vcCk7XG5cbmNhbnZhcy5vbm1vdXNlbW92ZSA9IChlKSA9PiB7XG4gICAgaWYgKGUuYnV0dG9ucyA+IDApIHtcbiAgICAgICAgZ2FtZS5jbGljayhlLm9mZnNldFggLyAoQ0VMTF9TSVpFICsgMSksIGUub2Zmc2V0WSAvIChDRUxMX1NJWkUgKyAxKSk7XG4gICAgfVxufTtcblxuY2FudmFzLm9uY2xpY2sgPSAoZSkgPT4ge1xuICAgIGdhbWUuY2xpY2soZS5vZmZzZXRYIC8gKENFTExfU0laRSArIDEpLCBlLm9mZnNldFkgLyAoQ0VMTF9TSVpFICsgMSkpO1xufTtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBnYW1lLnVuZm9jdXMoKTtcbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGdhbWUudW5mb2N1cygpO1xufSk7XG5cbmxldCBpc19zaGlmdF9kb3duID0gKCkgPT4ge1xuICAgIHJldHVybiBkaWdfY2hlY2tib3guY2hlY2tlZDtcblxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgYnV0dG9ucyBieSBrZXlcbmNvbnN0IGZpbmRCdXR0b25zQnlLZXkgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vdmUtYnV0dG9uLCAubW92ZS1idXR0b24tY2hlY2tib3gnKSkuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IChlbC5kYXRhc2V0LmtleXMgfHwgJycpLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBrZXlzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgdG8gYWN0aXZhdGUvZGVhY3RpdmF0ZSBidXR0b25zXG5jb25zdCBhY3RpdmF0ZUJ1dHRvbiA9IChidXR0b24pID0+IHtcbiAgICBpZiAoYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygnbW92ZS1idXR0b24tY2hlY2tib3gnKSkge1xuICAgICAgICBpZiAoIWJ1dHRvbi5kYXRhc2V0LmtleXMpIHJldHVybjsgLy8gU2tpcCBidXR0b25zIHdpdGhvdXQga2V5IG1hcHBpbmdzXG4gICAgICAgIGNvbnN0IGtleXMgPSBidXR0b24uZGF0YXNldC5rZXlzLnNwbGl0KCcsJyk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXNzZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgY2hhbmdlIGV2ZW50IHNvIGhhbmRsZXJzIGFyZSBub3RpZmllZFxuICAgICAgICBidXR0b24uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgfVxufTtcblxuY29uc3QgZGVhY3RpdmF0ZUJ1dHRvbiA9IChidXR0b24pID0+IHtcbiAgICBpZiAoYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygnbW92ZS1idXR0b24tY2hlY2tib3gnKSkge1xuICAgICAgICBpZiAoIWJ1dHRvbi5kYXRhc2V0LmtleXMpIHJldHVybjsgLy8gU2tpcCBidXR0b25zIHdpdGhvdXQga2V5IG1hcHBpbmdzXG4gICAgICAgIGNvbnN0IGtleXMgPSBidXR0b24uZGF0YXNldC5rZXlzLnNwbGl0KCcsJyk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmVzc2VkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBjaGFuZ2UgZXZlbnQgc28gaGFuZGxlcnMgYXJlIG5vdGlmaWVkXG4gICAgICAgIGJ1dHRvbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICB9XG59O1xuXG4vLyBUcmFjayBjdXJyZW50bHkgcHJlc3NlZCBrZXlzXG5jb25zdCBwcmVzc2VkS2V5cyA9IG5ldyBTZXQoKTtcbmxldCBzaGlmdFRvZ2dsZWQgPSBmYWxzZTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBrZXkgbmFtZXNcbmNvbnN0IG5vcm1hbGl6ZUtleSA9IChrZXkpID0+IHtcbiAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdhcnJvd3VwJzogcmV0dXJuICd3JztcbiAgICAgICAgY2FzZSAnYXJyb3dkb3duJzogcmV0dXJuICdzJztcbiAgICAgICAgY2FzZSAnYXJyb3dsZWZ0JzogcmV0dXJuICdhJztcbiAgICAgICAgY2FzZSAnYXJyb3dyaWdodCc6IHJldHVybiAnZCc7XG4gICAgICAgIGNhc2UgJyAnOiByZXR1cm4gJyAnO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufTtcblxuY29uc3QgZmluZEJ1dHRvbkVsZW1lbnRzID0gKCkgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb3ZlLWJ1dHRvbiwgLm1vdmUtYnV0dG9uLWNoZWNrYm94JykpO1xufTtcblxuLy8gVXBkYXRlIGFsbCBidXR0b24gc3RhdGVzIGJhc2VkIG9uIGN1cnJlbnRseSBwcmVzc2VkIGtleXNcbmNvbnN0IHVwZGF0ZUFsbEJ1dHRvblN0YXRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBlbGVtcyA9IGZpbmRCdXR0b25FbGVtZW50cygpO1xuXG4gICAgZWxlbXMuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgY29uc3QgYnV0dG9uS2V5cyA9IChlbC5kYXRhc2V0LmtleXMgfHwgJycpLnNwbGl0KCcsJykubWFwKGsgPT4gbm9ybWFsaXplS2V5KGspKTtcbiAgICAgICAgLy8gRm9yIGNvbWJpbmF0aW9uIGJ1dHRvbnMgKGUuZy4gdythKVxuICAgICAgICBpZiAoYnV0dG9uS2V5cy5ldmVyeShrZXkgPT4gcHJlc3NlZEtleXMuaGFzKGtleSkpKSB7XG4gICAgICAgICAgICBhY3RpdmF0ZUJ1dHRvbihlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWFjdGl2YXRlQnV0dG9uKGVsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLy8gSGFuZGxlIGtleWJvYXJkIGV2ZW50c1xuZG9jdW1lbnQub25rZXlkb3duID0gKGUpID0+IHtcbiAgICBjb25zdCBrZXkgPSBub3JtYWxpemVLZXkoZS5rZXkpO1xuICAgIHByZXNzZWRLZXlzLmFkZChrZXkpO1xuICAgIHRvdWNoZXMudGV4dENvbnRlbnQgPSBrZXk7XG4gICAgZ2FtZS5rZXlfZG93bihrZXkpO1xuICAgIHVwZGF0ZUFsbEJ1dHRvblN0YXRlcygpO1xufTtcblxuZG9jdW1lbnQub25rZXl1cCA9IChlKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gbm9ybWFsaXplS2V5KGUua2V5KTtcbiAgICBwcmVzc2VkS2V5cy5kZWxldGUoa2V5KTtcbiAgICB0b3VjaGVzLnRleHRDb250ZW50ID0ga2V5O1xuICAgIGdhbWUua2V5X3VwKGtleSk7XG4gICAgdXBkYXRlQWxsQnV0dG9uU3RhdGVzKCk7XG59O1xuXG4vLyBDbGVhciBwcmVzc2VkIGtleXMgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbndpbmRvdy5vbmJsdXIgPSAoKSA9PiB7XG4gICAgcHJlc3NlZEtleXMuY2xlYXIoKTtcbiAgICB1cGRhdGVBbGxCdXR0b25TdGF0ZXMoKTtcbn07XG5cbi8vIFNldHVwIGNvbnRyb2wgYnV0dG9uc1xuY29uc3Qgc2V0dXBDb250cm9sQnV0dG9ucyA9ICgpID0+IHtcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBzaGlmdCBjaGVja2JveFxuICAgIGNvbnN0IHRvZ2dsZUJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW92ZS1idXR0b24tY2hlY2tib3gnKTtcbiAgICB0b2dnbGVCdXR0b25zLmZvckVhY2goY2hlY2tib3ggPT4ge1xuICAgICAgICBpZiAoIWNoZWNrYm94LmRhdGFzZXQua2V5cykgcmV0dXJuOyAvLyBTa2lwIGJ1dHRvbnMgd2l0aG91dCBrZXkgbWFwcGluZ3NcbiAgICAgICAgY29uc3Qga2V5cyA9IGNoZWNrYm94LmRhdGFzZXQua2V5cy5zcGxpdCgnLCcpO1xuICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcygnc2hpZnQnKSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFkZCgnc2hpZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5rZXlfZG93bignc2hpZnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5kZWxldGUoJ3NoaWZ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGdhbWUua2V5X3VwKCdzaGlmdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZUNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm47IC8vIFNraXAgcmVndWxhciBldmVudCBiaW5kaW5nIGZvciBzaGlmdCBidXR0b25cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb3ZlLWJ1dHRvbicpO1xuXG4gICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGlmICghYnV0dG9uLmRhdGFzZXQua2V5cykgcmV0dXJuOyAvLyBTa2lwIGJ1dHRvbnMgd2l0aG91dCBrZXkgbWFwcGluZ3NcbiAgICAgICAgY29uc3Qga2V5cyA9IGJ1dHRvbi5kYXRhc2V0LmtleXMuc3BsaXQoJywnKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIkJ1dHRvbjogXCIsIGJ1dHRvbiwgXCJLZXlzOiBcIiwga2V5cyk7XG4gICAgICAgIGNvbnN0IHByZXNzS2V5cyA9ICgpID0+IGtleXMuZm9yRWFjaChrZXkgPT4gZ2FtZS5rZXlfZG93bihrZXkpKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUtleXMgPSAoKSA9PiBrZXlzLmZvckVhY2goa2V5ID0+IGdhbWUua2V5X3VwKGtleSkpO1xuXG4gICAgICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgcHJlc3NLZXlzKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCByZWxlYXNlS2V5cyk7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVsZWFzZUtleXMpO1xuXG4gICAgICAgIC8vIFRvdWNoIGV2ZW50c1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZG91YmxlLWZpcmluZyBvbiBtb2JpbGVcbiAgICAgICAgICAgIHByZXNzS2V5cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlbGVhc2VLZXlzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVsZWFzZUtleXMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQmx1ciBldmVudCAod2hlbiBidXR0b24gbG9zZXMgZm9jdXMpXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgcmVsZWFzZUtleXMpO1xuICAgIH0pO1xuXG5cbn07XG5cbi8vIEluaXRpYWxpemUgY29udHJvbHNcbnNldHVwQ29udHJvbEJ1dHRvbnMoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ })

}]);